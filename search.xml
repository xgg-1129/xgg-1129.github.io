<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go类型系统</title>
    <url>/2021/10/13/Go%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="类型是什么"><a href="#类型是什么" class="headerlink" title="类型是什么"></a>类型是什么</h2><p>计算机只能理解0和1，只认识一堆存有0和1的寄存器，所以类型是编程语言基于汇编语言的一种抽象实现，它能够把我们写的类型<strong>值</strong>按照一种特定的方式转化为汇编语言。</p>
<h2 id="类型系统是什么"><a href="#类型系统是什么" class="headerlink" title="类型系统是什么"></a>类型系统是什么</h2><p>任何语言都有自己的类型系统，任何“值”也都唯一的属于某种类型。</p>
<p>一个“值”只有有自己的类型，才能被编译器所识别，从而正确的为其分配内存和使用。</p>
<p>类型为编译器提供了两种信息：</p>
<ol>
<li>类型的规模，即需要为该种类型的“值”分配多少内存；</li>
<li>内存的表示，即这段内存表示的是什么。</li>
</ol>
<p><strong>所以一个语言的类型系统指明：哪些操作对哪些类型是有效的。(一个类型允许进行哪些操作)用于强制这些二进制数据按照我们预期的值来解析，确保在一个整数的二进制格式上不会做任何非整数的操作，从而获取一些毫无意义的东西。</strong></p>
<h2 id="GoLang类型元数据"><a href="#GoLang类型元数据" class="headerlink" title="GoLang类型元数据"></a>GoLang类型元数据</h2><p>类型元数据承载了一个类型的所有信息，每种数据的类型元数据全局唯一。如下图所示，第一个方框格为每个类型元数据的Header，存放了名字、对其边界等必备信息，中间的方框格用来存放一些补充信息，如果是自定义类型，则会有第三个方框格，记录类型的包路径、方法个数、和一个记录了方法元数据数组的指针。</p>
<p><img src="/images/post1.png" alt="Alt text"></p>
<p>一个[]String类型的元数据如下</p>
<p><img src="/images/post2.png" alt="Alt text"></p>
<h2 id="type-MyType1-int32和type-MyType2-int32的区别"><a href="#type-MyType1-int32和type-MyType2-int32的区别" class="headerlink" title="type MyType1 int32和type MyType2=int32的区别"></a>type MyType1 int32和type MyType2=int32的区别</h2><p>前者是类型别名写法不创建新的类型元数据，后者是创建新的自定义类型，会创建新的类型元数据</p>
<p><img src="/images/post3.png" alt="Alt text"></p>
<h2 id="命名类型和未命名类型"><a href="#命名类型和未命名类型" class="headerlink" title="命名类型和未命名类型"></a>命名类型和未命名类型</h2><p>具有名称的类型就是命名类型，例如：<code>int</code>, <code>int64</code>, <code>float32</code>, <code>string</code>, <code>bool</code>等。</p>
<p>没有名称的类型就是未命名类型，例如数组，结构体，指针，函数，接口，切片，map，通道 都是未命名类型。【我的理解就是引用类型都是未命名类型】</p>
<h2 id="底层类型"><a href="#底层类型" class="headerlink" title="底层类型"></a>底层类型</h2><p>GoLang中，每个类型都有自己的底层类型【我猜测就是类型元数据中的Head】，底层类型在类型转换和赋值、比较中扮演着重要的属性。</p>
<ul>
<li>底层类型为内置类型<code>bool</code>的类型称为<strong>布尔类型</strong>；</li>
<li>底层类型为任一内置整数类型的类型称为<strong>整数类型</strong>；</li>
<li>底层类型为内置类型<code>float32</code>或者<code>float64</code>的类型称为<strong>浮点数类型</strong>；</li>
<li>底层类型为内置类型<code>complex64</code>或<code>complex128</code>的类型称为<strong>复数类型</strong>；</li>
<li>整数类型、浮点数类型和复数类型统称为<strong>数字值类型</strong>；</li>
<li>底层类型为内置类型<code>string</code>的类型称为<strong>字符串类型</strong>。</li>
</ul>
<h2 id="赋值条件"><a href="#赋值条件" class="headerlink" title="赋值条件"></a>赋值条件</h2><p>双方应该具有相同的基础类型，而且其中至少有一个不是命名类型(至少有一个是未命名变类型)。</p>
<h2 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h2><p>反射的原理就是将暴露类型的元数据给我们用</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ce307b8e9772">深入研究Go(golang) Type类型系统</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/139347413">GO的类型系统和类型的方法</a></p>
<p><a href="https://gfw.go101.org/article/type-system-overview.html">Go101类型系统概述</a></p>
<p><a href="https://blog.csdn.net/weixin_36228538/article/details/115111509">GoLang类型系统</a></p>
<p><a href="https://www.bilibili.com/video/BV1hv411x7we?p=12">幼麟实验室</a></p>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
      </tags>
  </entry>
  <entry>
    <title>GoLang字符串</title>
    <url>/2021/10/11/GoLang%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的本质实际就是一片连续的内存空间，我们通常可以把他理解为一个字符数组，Go语言的字符串是一片只读的字节数组。</p>
<h3 id="内存中的字符串"><a href="#内存中的字符串" class="headerlink" title="内存中的字符串"></a>内存中的字符串</h3><p>如果是代码中存在的字符串，编译器会将其标记成只读数据 <code>SRODATA</code>，假设我们有以下代码，其中包含了一个字符串，当我们将这段代码编译成汇编语言时，就能够看到 <code>hello</code> 字符串有一个 <code>SRODATA</code> 的标记</p>
<p>//禁止内联生成汇编代码</p>
<p>GOOS=linux GOARCH=amd64 go tool compile -S main.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">	<span class="built_in">println</span>([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOOS=linux GOARCH=amd64 <span class="keyword">go</span> tool compile -S main.<span class="keyword">go</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">&quot;hello&quot;</span> SRODATA dupok size=<span class="number">5</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f  </span><br></pre></td></tr></table></figure>

<p>只读只意味着字符串会分配到只读的内存空间【数据段+代码=制度空间】，我们不可以直接修改 <code>string</code>类型变量的内存空间。</p>
<h3 id="字符串的数据结构"><a href="#字符串的数据结构" class="headerlink" title="字符串的数据结构"></a>字符串的数据结构</h3><p>字符串在运行的时候用StringHeader表示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span> <span class="comment">//数据指针</span></span><br><span class="line">	Len  <span class="keyword">int</span>	 <span class="comment">//字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串是只读空间，我们无法向字符串追加元素改变它的内存空间，所有字符串的修改操作都是通过拷贝实现的。字符串运行时调用copy将多个字符串拷贝到新的内存空间，这样的内存拷贝是比较消耗性能的。</p>
<h3 id="字符串和-byte的转换"><a href="#字符串和-byte的转换" class="headerlink" title="字符串和[]byte的转换"></a>字符串和[]byte的转换</h3><p>字符串和[]byte底层内容都是一样的，但是[]byte是可读可写的【堆栈】，类型转换通常使用截断或者拷贝完成，像字符串和[]byte这样处于不同类型内存空间的数据转换时会产生内存拷贝。</p>
<h3 id="Len-String"><a href="#Len-String" class="headerlink" title="Len(String)"></a>Len(String)</h3><p>String底层是[]byte,它的len返回的是字节长度，所以len(“我”)!=1</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/355082331">Golang的String解析</a></p>
<p><a href="https://www.bilibili.com/video/BV1hv411x7we?spm_id_from=333.999.0.0">幼麟实验室</a></p>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/#344-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">Draveness字符串解析</a></p>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP连接队列</title>
    <url>/2021/10/12/TCP%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2021/10/10/Map/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h3 id="map是什么？"><a href="#map是什么？" class="headerlink" title="map是什么？"></a>map是什么？</h3><p>map是一种通过key获取value 的抽象数据结构，通常基于哈希表或者搜索树实现，哈希表平均查找速度快O(1),最快是O(N)，自平衡搜索树稳定 O(logN)，但是搜索树会进行很多为了维持自己的平衡的操作，所以map一般基于HashTable实现。</p>
<h3 id="设计一个哈希表需要考虑哪些因素"><a href="#设计一个哈希表需要考虑哪些因素" class="headerlink" title="设计一个哈希表需要考虑哪些因素"></a>设计一个哈希表需要考虑哪些因素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.1哈希函数如何设计？合理的哈希函数能够提高每个内存的命中和减少哈希碰撞</span><br><span class="line">2.2如何解决哈希冲突？用树还是红黑树？【应该没有语言会用探测法解决哈希冲突吧】</span><br><span class="line">2.3负载因子的大小如何设置，设置为多大才合理？</span><br><span class="line">2.4如何扩容？</span><br></pre></td></tr></table></figure>

<h3 id="一个基于简单拉链法实现的HashMap"><a href="#一个基于简单拉链法实现的HashMap" class="headerlink" title="一个基于简单拉链法实现的HashMap"></a>一个基于简单拉链法实现的HashMap</h3><p>HashMap结构如下,<a href="https://github.com/xgg-1129/XggContainer/tree/master/HashTable">代码</a></p>
<p>取模法寻址过程为  hash(key) % size</p>
<p><img src="/images/HashMap.png" alt="Alt text"></p>
<h3 id="Golang中基于哈希表实现的Map"><a href="#Golang中基于哈希表实现的Map" class="headerlink" title="Golang中基于哈希表实现的Map"></a>Golang中基于哈希表实现的Map</h3><p><img src="https://pic2.zhimg.com/v2-0178a76f87bb68fd7a645e6885e17525_b.jpg" alt="Alt text"></p>
<p>GoLang的数组存储的不是直接存储一个键值对，而是存储一个bucket，bucket里面存储了8个键值对信息。</p>
<h4 id="定位函数的设计"><a href="#定位函数的设计" class="headerlink" title="定位函数的设计"></a>定位函数的设计</h4><p>定位函数一般有取模法和与运算，Golang采用的是与运算的设计方案，这种方案要求哈希数组的个数必须是2的整数次幂，这样能够确保不会出现空桶。</p>
<h4 id="链表哈希冲突"><a href="#链表哈希冲突" class="headerlink" title="链表哈希冲突"></a>链表哈希冲突</h4><p>golang用链表解决哈希冲突</p>
<h4 id="寻址过程"><a href="#寻址过程" class="headerlink" title="寻址过程"></a>寻址过程</h4><p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。</p>
<p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</span><br></pre></td></tr></table></figure>

<p>用最后的 5 个 bit 位，也就是 <code>01010</code>，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。</p>
<p>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p>
<p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p>
<p>key定位流程图</p>
<p><img src="https://pic3.zhimg.com/v2-dcc95d8e32ba33275a26136749b909fe_b.jpg" alt="img"></p>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果一次性把大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。而且，golang的扩容机智，一定会将golang的旧桶分裂到二个新桶，减少了哈希冲突的概率。</p>
<h4 id="map可以一边遍历一边删除吗"><a href="#map可以一边遍历一边删除吗" class="headerlink" title="map可以一边遍历一边删除吗"></a>map可以一边遍历一边删除吗</h4><p>map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p>
<h4 id="key可以是float吗"><a href="#key可以是float吗" class="headerlink" title="key可以是float吗"></a>key可以是float吗</h4><p>从语法上看，是可以的。Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 <code>==</code> 和 <code>!=</code> 操作符，<code>k1 == k2</code> 时，可认为 k1 和 k2 是同一个 key。如果是结构体，则需要它们的字段值都相等，才被认为是相同的 key。任何类型都可以作为 value，包括 map 类型。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go 语言中，通过哈希查找表实现 map，用链表法解决哈希冲突。</p>
<p>通过 key 的哈希值将 key 散落到不同的桶中，每个桶中有 8 个 cell。哈希值的低位决定桶序号，高位标识同一个桶中的不同 key。</p>
<p>当向桶中添加了很多 key，造成元素过多，或者溢出桶太多，就会触发扩容。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/66676224">深度解密Go语言map</a></p>
<p><a href="https://www.bilibili.com/video/BV1Sp4y1U7dJ?spm_id_from=333.999.0.0">幼麟实验室</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>动态数组Slice</title>
    <url>/2021/10/12/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84Slice/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种抽象的数据结构，他代表了一个相同类型元素的集合，计算机会为数组分配一块连续的内存区域来保存元素，我们可以通过下标快速访问特定元素。</p>
<h3 id="GoLang数组的内存区域"><a href="#GoLang数组的内存区域" class="headerlink" title="GoLang数组的内存区域"></a>GoLang数组的内存区域</h3><p>在不考虑内存逃逸的情况下，数组中的所有元素最终都是存储在栈中【如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上】-&gt; 不知道为啥要这么设计。。</p>
<h3 id="GoLang数组总结"><a href="#GoLang数组总结" class="headerlink" title="GoLang数组总结"></a>GoLang数组总结</h3><p>数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成直接读写内存。【奈何编译原理的知识储备不足，很多GoLang数组的底层特性无法深入，但是学编译原理的性价比太低了】</p>
<h2 id="GoLang切片"><a href="#GoLang切片" class="headerlink" title="GoLang切片"></a>GoLang切片</h2><p>数组在编译期间必须确定大小，使用起来不太方便，所以在 Go 语言中没那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。</p>
<h3 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h3><p>切片本质就是一个结构体，源码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span> <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>slice</code> 共有三个属性： <code>指针</code>，指向底层数组； <code>长度</code>，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度； <code>容量</code>，底层数组的元素个数，容量 &gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。</p>
<h3 id="切片的内存区域"><a href="#切片的内存区域" class="headerlink" title="切片的内存区域"></a>切片的内存区域</h3><p>当切片发生逃逸或者非常大时，运行时需要 <a href="https://draveness.me/golang/tree/runtime.makeslice"><code>runtime.makeslice</code></a> 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">n := arr[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>append会向底层的数组追加元素，如果底层数组已满会触发扩容机制，在内存中新找一片区域作为新的底层数组。</p>
<p>扩容机制</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量;</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>切片虽然十分灵活，但是切片的追加操作会引起内存的扩容和拷贝，大规模的内存拷贝十分影响程序的性能，所以使用切片前最好估计一下需要的内存最大值，然后一次性申请个大切片【超过限制的申请会直接panic】。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99">golangSlice的扩容规则</a></p>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/#324-%E8%BF%BD%E5%8A%A0%E5%92%8C%E6%89%A9%E5%AE%B9">Drave切片解析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/61121325">深度解密Golang切片</a></p>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
      </tags>
  </entry>
</search>
