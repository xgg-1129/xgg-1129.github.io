<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C10K问题</title>
    <url>/2021/10/14/C10K%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>
<p><a href="https://zhuanlan.zhihu.com/p/51078499">https://zhuanlan.zhihu.com/p/51078499</a></p>
]]></content>
  </entry>
  <entry>
    <title>Defer</title>
    <url>/2021/10/15/Defer/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2021/10/15/Function-Value%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="FunctionValue"><a href="#FunctionValue" class="headerlink" title="FunctionValue"></a>FunctionValue</h2><p> FunctionValue是个指针，但是他不是函数指针，它指向了一个结构体，结构体里有函数指针【函数指针指向了入口地址】，如果用FunctionValue调用函数，则FunctionValue先找到结构体，结构体通过函数指针调用函数。</p>
<p>其实只要有函数指针就可以完成调用的函数，FunctionValue的意义事什么呢？</p>
<p>答案就是：闭包</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>我个人对闭包的理解是，一个函数绑定了一个在外面定义的变量【这里简称绑定变量】。FunctionValue指向的结构体的作用不仅保存了函数指针，同时保存绑定变量的信息，把函数运行的上下文环境包裹起来。【这样看来闭包这个词还是很形象的】</p>
<h3 id="闭包的几种情况"><a href="#闭包的几种情况" class="headerlink" title="闭包的几种情况"></a>闭包的几种情况</h3><h4 id="捕获不变的变量"><a href="#捕获不变的变量" class="headerlink" title="捕获不变的变量"></a>捕获不变的变量</h4><p>如果闭包函数绑定的变量不会改变，则直接在FunctionValue指向的结构体里，复制变量的拷贝即可。</p>
<img src="/images/func1.png" width="60%"  />

<h4 id="捕获改变的局部变量"><a href="#捕获改变的局部变量" class="headerlink" title="捕获改变的局部变量"></a>捕获改变的局部变量</h4><p>如果闭包函数需要绑定一个会改变的局部变量，则会把这个局部变量分配至堆【内存逃逸】，然后FunctionValue指向的结构体里复制这个堆变量的指针。</p>
<img src="/images/func2.png" width="70%"  />

<h4 id="捕获参数"><a href="#捕获参数" class="headerlink" title="捕获参数"></a>捕获参数</h4><p>如果需要绑定传递的参数，则会在栈和堆上都分配 参数，但是会绑定堆上的那个参数。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1hv411x7we?p=7">幼麟实验室</a></p>
]]></content>
      <tags>
        <tag>GoLang</tag>
      </tags>
  </entry>
  <entry>
    <title>GoLang字符串</title>
    <url>/2021/10/11/GoLang%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的本质实际就是一片连续的内存空间，我们通常可以把他理解为一个字符数组，Go语言的字符串是一片只读的字节数组。</p>
<h3 id="内存中的字符串"><a href="#内存中的字符串" class="headerlink" title="内存中的字符串"></a>内存中的字符串</h3><p>如果是代码中存在的字符串，编译器会将其标记成只读数据 <code>SRODATA</code>，假设我们有以下代码，其中包含了一个字符串，当我们将这段代码编译成汇编语言时，就能够看到 <code>hello</code> 字符串有一个 <code>SRODATA</code> 的标记</p>
<p>//禁止内联生成汇编代码</p>
<p>GOOS=linux GOARCH=amd64 go tool compile -S main.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">	<span class="built_in">println</span>([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOOS=linux GOARCH=amd64 <span class="keyword">go</span> tool compile -S main.<span class="keyword">go</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">&quot;hello&quot;</span> SRODATA dupok size=<span class="number">5</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f  </span><br></pre></td></tr></table></figure>

<p>只读只意味着字符串会分配到只读的内存空间【数据段+代码=制度空间】，我们不可以直接修改 <code>string</code>类型变量的内存空间。</p>
<h3 id="字符串的数据结构"><a href="#字符串的数据结构" class="headerlink" title="字符串的数据结构"></a>字符串的数据结构</h3><p>字符串在运行的时候用StringHeader表示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span> <span class="comment">//数据指针</span></span><br><span class="line">	Len  <span class="keyword">int</span>	 <span class="comment">//字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串是只读空间，我们无法向字符串追加元素改变它的内存空间，所有字符串的修改操作都是通过拷贝实现的。字符串运行时调用copy将多个字符串拷贝到新的内存空间，这样的内存拷贝是比较消耗性能的。</p>
<h3 id="字符串和-byte的转换"><a href="#字符串和-byte的转换" class="headerlink" title="字符串和[]byte的转换"></a>字符串和[]byte的转换</h3><p>字符串和[]byte底层内容都是一样的，但是[]byte是可读可写的【堆栈】，类型转换通常使用截断或者拷贝完成，像字符串和[]byte这样处于不同类型内存空间的数据转换时会产生内存拷贝。</p>
<h3 id="Len-String"><a href="#Len-String" class="headerlink" title="Len(String)"></a>Len(String)</h3><p>String底层是[]byte,它的len返回的是字节长度，所以len(“我”)!=1</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/355082331">Golang的String解析</a></p>
<p><a href="https://www.bilibili.com/video/BV1hv411x7we?spm_id_from=333.999.0.0">幼麟实验室</a></p>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/#344-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">Draveness字符串解析</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go类型系统</title>
    <url>/2021/10/13/Go%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="类型是什么"><a href="#类型是什么" class="headerlink" title="类型是什么"></a>类型是什么</h2><p>计算机只能理解0和1，只认识一堆存有0和1的寄存器，所以类型是编程语言基于汇编语言的一种抽象实现，它能够把我们写的类型<strong>值</strong>按照一种特定的方式转化为汇编语言。</p>
<h2 id="类型系统是什么"><a href="#类型系统是什么" class="headerlink" title="类型系统是什么"></a>类型系统是什么</h2><p>任何语言都有自己的类型系统，任何“值”也都唯一的属于某种类型。</p>
<p>一个“值”只有有自己的类型，才能被编译器所识别，从而正确的为其分配内存和使用。</p>
<p>类型为编译器提供了两种信息：</p>
<ol>
<li>类型的规模，即需要为该种类型的“值”分配多少内存；</li>
<li>内存的表示，即这段内存表示的是什么。</li>
</ol>
<p><strong>所以一个语言的类型系统指明：哪些操作对哪些类型是有效的。(一个类型允许进行哪些操作)用于强制这些二进制数据按照我们预期的值来解析，确保在一个整数的二进制格式上不会做任何非整数的操作，从而获取一些毫无意义的东西。</strong></p>
<h2 id="GoLang类型元数据"><a href="#GoLang类型元数据" class="headerlink" title="GoLang类型元数据"></a>GoLang类型元数据</h2><p>类型元数据承载了一个类型的所有信息，每种数据的类型元数据全局唯一。如下图所示，第一个方框格为每个类型元数据的Header，存放了名字、对其边界等必备信息，中间的方框格用来存放一些补充信息，如果是自定义类型，则会有第三个方框格，记录类型的包路径、方法个数、和一个记录了方法元数据数组的指针。</p>
<p><img src="/images/post1.png" alt="Alt text"></p>
<p>一个[]String类型的元数据如下</p>
<p><img src="/images/post2.png" alt="Alt text"></p>
<h2 id="type-MyType1-int32和type-MyType2-int32的区别"><a href="#type-MyType1-int32和type-MyType2-int32的区别" class="headerlink" title="type MyType1 int32和type MyType2=int32的区别"></a>type MyType1 int32和type MyType2=int32的区别</h2><p>前者是类型别名写法不创建新的类型元数据，后者是创建新的自定义类型，会创建新的类型元数据</p>
<p><img src="/images/post3.png" alt="Alt text"></p>
<h2 id="命名类型和未命名类型"><a href="#命名类型和未命名类型" class="headerlink" title="命名类型和未命名类型"></a>命名类型和未命名类型</h2><p>具有名称的类型就是命名类型，例如：<code>int</code>, <code>int64</code>, <code>float32</code>, <code>string</code>, <code>bool</code>等。</p>
<p>没有名称的类型就是未命名类型，例如数组，结构体，指针，函数，接口，切片，map，通道 都是未命名类型。【我的理解就是引用类型都是未命名类型】</p>
<h2 id="底层类型"><a href="#底层类型" class="headerlink" title="底层类型"></a>底层类型</h2><p>GoLang中，每个类型都有自己的底层类型【我猜测就是类型元数据中的Head】，底层类型在类型转换和赋值、比较中扮演着重要的属性。</p>
<ul>
<li>底层类型为内置类型<code>bool</code>的类型称为<strong>布尔类型</strong>；</li>
<li>底层类型为任一内置整数类型的类型称为<strong>整数类型</strong>；</li>
<li>底层类型为内置类型<code>float32</code>或者<code>float64</code>的类型称为<strong>浮点数类型</strong>；</li>
<li>底层类型为内置类型<code>complex64</code>或<code>complex128</code>的类型称为<strong>复数类型</strong>；</li>
<li>整数类型、浮点数类型和复数类型统称为<strong>数字值类型</strong>；</li>
<li>底层类型为内置类型<code>string</code>的类型称为<strong>字符串类型</strong>。</li>
</ul>
<h2 id="赋值条件"><a href="#赋值条件" class="headerlink" title="赋值条件"></a>赋值条件</h2><p>双方应该具有相同的基础类型，而且其中至少有一个不是命名类型(至少有一个是未命名变类型)。</p>
<h2 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h2><p>反射的原理就是将暴露类型的元数据给我们用</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ce307b8e9772">深入研究Go(golang) Type类型系统</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/139347413">GO的类型系统和类型的方法</a></p>
<p><a href="https://gfw.go101.org/article/type-system-overview.html">Go101类型系统概述</a></p>
<p><a href="https://blog.csdn.net/weixin_36228538/article/details/115111509">GoLang类型系统</a></p>
<p><a href="https://www.bilibili.com/video/BV1hv411x7we?p=12">幼麟实验室</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP连接队列</title>
    <url>/2021/10/12/TCP%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2021/10/10/Map/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h3 id="map是什么？"><a href="#map是什么？" class="headerlink" title="map是什么？"></a>map是什么？</h3><p>map是一种通过key获取value 的抽象数据结构，通常基于哈希表或者搜索树实现，哈希表平均查找速度快O(1),最快是O(N)，自平衡搜索树稳定 O(logN)，但是搜索树会进行很多为了维持自己的平衡的操作，所以map一般基于HashTable实现。</p>
<h3 id="设计一个哈希表需要考虑哪些因素"><a href="#设计一个哈希表需要考虑哪些因素" class="headerlink" title="设计一个哈希表需要考虑哪些因素"></a>设计一个哈希表需要考虑哪些因素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.1哈希函数如何设计？合理的哈希函数能够提高每个内存的命中和减少哈希碰撞</span><br><span class="line">2.2如何解决哈希冲突？用树还是红黑树？【应该没有语言会用探测法解决哈希冲突吧】</span><br><span class="line">2.3负载因子的大小如何设置，设置为多大才合理？</span><br><span class="line">2.4如何扩容？</span><br></pre></td></tr></table></figure>

<h3 id="一个基于简单拉链法实现的HashMap"><a href="#一个基于简单拉链法实现的HashMap" class="headerlink" title="一个基于简单拉链法实现的HashMap"></a>一个基于简单拉链法实现的HashMap</h3><p>HashMap结构如下,<a href="https://github.com/xgg-1129/XggContainer/tree/master/HashTable">代码</a></p>
<p>取模法寻址过程为  hash(key) % size</p>
<p><img src="/images/HashMap.png" alt="Alt text"></p>
<h3 id="Golang中基于哈希表实现的Map"><a href="#Golang中基于哈希表实现的Map" class="headerlink" title="Golang中基于哈希表实现的Map"></a>Golang中基于哈希表实现的Map</h3><p><img src="https://pic2.zhimg.com/v2-0178a76f87bb68fd7a645e6885e17525_b.jpg" alt="Alt text"></p>
<p>GoLang的数组存储的不是直接存储一个键值对，而是存储一个bucket，bucket里面存储了8个键值对信息。</p>
<h4 id="定位函数的设计"><a href="#定位函数的设计" class="headerlink" title="定位函数的设计"></a>定位函数的设计</h4><p>定位函数一般有取模法和与运算，Golang采用的是与运算的设计方案，这种方案要求哈希数组的个数必须是2的整数次幂，这样能够确保不会出现空桶。</p>
<h4 id="链表哈希冲突"><a href="#链表哈希冲突" class="headerlink" title="链表哈希冲突"></a>链表哈希冲突</h4><p>golang用链表解决哈希冲突</p>
<h4 id="寻址过程"><a href="#寻址过程" class="headerlink" title="寻址过程"></a>寻址过程</h4><p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。</p>
<p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</span><br></pre></td></tr></table></figure>

<p>用最后的 5 个 bit 位，也就是 <code>01010</code>，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。</p>
<p>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p>
<p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p>
<p>key定位流程图</p>
<p><img src="https://pic3.zhimg.com/v2-dcc95d8e32ba33275a26136749b909fe_b.jpg" alt="img"></p>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果一次性把大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。而且，golang的扩容机智，一定会将golang的旧桶分裂到二个新桶，减少了哈希冲突的概率。</p>
<h4 id="map可以一边遍历一边删除吗"><a href="#map可以一边遍历一边删除吗" class="headerlink" title="map可以一边遍历一边删除吗"></a>map可以一边遍历一边删除吗</h4><p>map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p>
<h4 id="key可以是float吗"><a href="#key可以是float吗" class="headerlink" title="key可以是float吗"></a>key可以是float吗</h4><p>从语法上看，是可以的。Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 <code>==</code> 和 <code>!=</code> 操作符，<code>k1 == k2</code> 时，可认为 k1 和 k2 是同一个 key。如果是结构体，则需要它们的字段值都相等，才被认为是相同的 key。任何类型都可以作为 value，包括 map 类型。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go 语言中，通过哈希查找表实现 map，用链表法解决哈希冲突。</p>
<p>通过 key 的哈希值将 key 散落到不同的桶中，每个桶中有 8 个 cell。哈希值的低位决定桶序号，高位标识同一个桶中的不同 key。</p>
<p>当向桶中添加了很多 key，造成元素过多，或者溢出桶太多，就会触发扩容。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/66676224">深度解密Go语言map</a></p>
<p><a href="https://www.bilibili.com/video/BV1Sp4y1U7dJ?spm_id_from=333.999.0.0">幼麟实验室</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>函数调用</title>
    <url>/2021/10/15/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="GoLang的函数参数传递"><a href="#GoLang的函数参数传递" class="headerlink" title="GoLang的函数参数传递"></a>GoLang的函数参数传递</h2><p>C 语言和 Go 语言在设计函数的调用惯例时选择了不同的实现。C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。我们可以对比一下这两种设计的优点和缺点：</p>
<ul>
<li>C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；<ul>
<li>CPU 访问栈的开销比访问寄存器高几十倍<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#fn:3">3</a>；</li>
<li>需要单独处理函数参数过多的情况；</li>
</ul>
</li>
<li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；<ul>
<li>不需要考虑超过寄存器数量的参数应该如何传递；</li>
<li>不需要考虑不同架构上的寄存器差异；</li>
<li>函数入参和出参的内存空间需要在栈上进行分配；</li>
</ul>
</li>
</ul>
<p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p>
<h2 id="GoLang的栈帧分配"><a href="#GoLang的栈帧分配" class="headerlink" title="GoLang的栈帧分配"></a>GoLang的栈帧分配</h2><p>GoLang采取一次性分配栈帧的方法，采用这种方法的原因是避免协程的函数栈帧越界到其他协程的内存区。</p>
<p>GoLang调用函数时，如果发现新栈帧所需的空间过大，则会在其他区域另外分配一块新的大栈，并把原来的数据拷贝过去，原来的空间被释放。</p>
<p><img src="/images/f.png" alt="image"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数调用的过程就是往栈里穿参数和返回地址，然后修改ESP和EBP的寄存器，形成新的栈帧，函数调用的时候可以通过新的EBP获取局部变量。</p>
]]></content>
      <tags>
        <tag>GoLang</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>内存对齐</title>
    <url>/2021/10/14/post%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="内存对齐概述"><a href="#内存对齐概述" class="headerlink" title="内存对齐概述"></a>内存对齐概述</h2><p>内存对齐就是将数据对齐到特定内存地址，提升处理器访问数据的速度，许多的体系结构都强制要求特定长度的数据类型进行特定的对齐。[其实这些编译器都会帮助我们完成，如果急着准备面试没必要看这个]</p>
<h2 id="1-4-2-12"><a href="#1-4-2-12" class="headerlink" title="1+4+2 = 12 ?"></a>1+4+2 = 12 ?</h2><img src="/images/struct.png" width="40%"  />

<h2 id="字"><a href="#字" class="headerlink" title="字"></a>字</h2><p>在我们程序员眼中的内存是一块<strong>字节数组</strong>，但是在CPU眼中是一块<strong>字数组</strong>，CPU的总线一次能传输固定大小的数据，这块数据的长度被称为<strong>字长/机器字长</strong>。<strong>字</strong>代表了CPU一次能加工和获取到的数据的最高字节数，字越大，CPU一次就能处理越多的数据。【cpu对访问任意内存字节的操作做了很多处理，例如你想访问的地址为1-8，字为8字节的cpu会进行2次寻址，第一次访问0-7取1-7，第二次访问8-15取7-8，然后将两个部分拼接起来】</p>
<h2 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h2><p><strong>平台原因</strong>：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>很多 CPU（如基于 Alpha，IA-64，MIPS，和 SuperH 体系的）拒绝读取未对齐数据。当一个程序要求这些 CPU 读取未对齐数据时，这时 CPU 会进入异常处理状态并且通知程序不能继续执行。举个例子，在 ARMMIPS，和 SH 硬件平台上，当操作系统被要求存取一个未对齐数据时会默认给应用程序抛出硬件异常。所以，如果编译器不进行内存对齐，那在很多平台的上的开发将难以进行。那么，为什么这些 CPU 会拒绝读取未对齐数据？是因为未对齐的数据，会大大降低 CPU 的性能。</p>
<p><strong>性能原因</strong>：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。字节对齐主要是为了提高内存的访问效率。</p>
<p>比如intel 32位cpu，每个总线周期都是从偶地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据，因此需要在内存中存放数据时进行对齐。</p>
<h2 id="内存对齐的方法"><a href="#内存对齐的方法" class="headerlink" title="内存对齐的方法"></a>内存对齐的方法</h2><p>每种数据类型在不同平台下都有自己的对齐边界，对齐边界规定了数据应该如何内存对齐，它的规则和使用方法有点复杂。【知道了过一阵子也会忘掉，如果有需要再查资料吧】</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/140063999">一文轻松理解内存对齐</a></p>
<p><a href="https://www.zhihu.com/question/27862634/answer/208895189">如何理解 struct 的内存对齐</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>动态数组Slice</title>
    <url>/2021/10/12/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84Slice/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种抽象的数据结构，他代表了一个相同类型元素的集合，计算机会为数组分配一块连续的内存区域来保存元素，我们可以通过下标快速访问特定元素。</p>
<h3 id="GoLang数组的内存区域"><a href="#GoLang数组的内存区域" class="headerlink" title="GoLang数组的内存区域"></a>GoLang数组的内存区域</h3><p>在不考虑内存逃逸的情况下，数组中的所有元素最终都是存储在栈中【如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上】-&gt; 不知道为啥要这么设计。。</p>
<h3 id="GoLang数组总结"><a href="#GoLang数组总结" class="headerlink" title="GoLang数组总结"></a>GoLang数组总结</h3><p>数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成直接读写内存。【奈何编译原理的知识储备不足，很多GoLang数组的底层特性无法深入，但是学编译原理的性价比太低了】</p>
<h2 id="GoLang切片"><a href="#GoLang切片" class="headerlink" title="GoLang切片"></a>GoLang切片</h2><p>数组在编译期间必须确定大小，使用起来不太方便，所以在 Go 语言中没那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。</p>
<h3 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h3><p>切片本质就是一个结构体，源码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span> <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>slice</code> 共有三个属性： <code>指针</code>，指向底层数组； <code>长度</code>，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度； <code>容量</code>，底层数组的元素个数，容量 &gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。</p>
<h3 id="切片的内存区域"><a href="#切片的内存区域" class="headerlink" title="切片的内存区域"></a>切片的内存区域</h3><p>当切片发生逃逸或者非常大时，运行时需要 <a href="https://draveness.me/golang/tree/runtime.makeslice"><code>runtime.makeslice</code></a> 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">n := arr[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>append会向底层的数组追加元素，如果底层数组已满会触发扩容机制，在内存中新找一片区域作为新的底层数组。</p>
<p>扩容机制</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量;</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>切片虽然十分灵活，但是切片的追加操作会引起内存的扩容和拷贝，大规模的内存拷贝十分影响程序的性能，所以使用切片前最好估计一下需要的内存最大值，然后一次性申请个大切片【超过限制的申请会直接panic】。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99">golangSlice的扩容规则</a></p>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/#324-%E8%BF%BD%E5%8A%A0%E5%92%8C%E6%89%A9%E5%AE%B9">Drave切片解析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/61121325">深度解密Golang切片</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>GoLang</tag>
      </tags>
  </entry>
  <entry>
    <title>协程</title>
    <url>/2021/10/15/%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="程序运行的上下文"><a href="#程序运行的上下文" class="headerlink" title="程序运行的上下文"></a>程序运行的上下文</h2><p>一个程序要真正运行起来，需要两个因素：可执行代码段、数据。体现在CPU中，主要包含以下几个方面： </p>
<ol>
<li><p>IP寄存器，用来存储CPU要读取指令的地址 </p>
</li>
<li><p>ESP、EBP寄存器：指向当前线程栈的栈顶位置 </p>
</li>
<li><p>其他通用寄存器的内容：包括代表函数参数的rdi、rsi等等。 </p>
</li>
<li><p>线程栈中的内存内容。</p>
</li>
</ol>
<h2 id="协程切换的优点"><a href="#协程切换的优点" class="headerlink" title="协程切换的优点"></a>协程切换的优点</h2><p>相比线程更加轻量级: 线程的创建和调度都是在内核态，而协程是在用户态完成的; 线程的个数往往受限于CPU核数，线程过多，会造成大量的核间切换。而协程无需考虑这些。</p>
<h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><p>1.有栈式和非栈式协程【协程的栈就是线程中的堆区】</p>
<p>2.对称和非对称</p>
<p>3…..还有一些根据调度机制等其他规则分类的协程【有需要再查吧】</p>
<h2 id="有栈协程的实现原理"><a href="#有栈协程的实现原理" class="headerlink" title="有栈协程的实现原理"></a>有栈协程的实现原理</h2><p>改变线程的部分上下文，也就是复用线程【复用和分层是计算机的重要思想】</p>
<h2 id="协程具体的实现方法"><a href="#协程具体的实现方法" class="headerlink" title="协程具体的实现方法"></a>协程具体的实现方法</h2><p>目前有如下几种方式来实现协程库。</p>
<h3 id="利用ucontext函数族来切换运行时上下文。"><a href="#利用ucontext函数族来切换运行时上下文。" class="headerlink" title="利用ucontext函数族来切换运行时上下文。"></a>利用ucontext函数族来切换运行时上下文。</h3><p>Linux下提供了一套函数，叫做ucontext簇函数，可以用来获取和设置当前线程的上下文内容，给用户让渡了一部分控制代码上下文的能力。【简单来说就是ucontext簇函数可以改变当前线程的上下文】<br> ucontext_t 中保存的上下文主要包括以下几个部分：<br> （1） 运行时各个寄存器的值<br> （2） 运行栈（堆就不用保存了，你存不存，他都在那里，不来不去）<br> （3） 信号<br> 基本上有了这些，就可以有效地在用户态保存线程运行现场。</p>
<p>参考资料：</p>
<p><a href="https://zhuanlan.zhihu.com/p/94018082">理解风云有栈协程实现原理</a></p>
<p><a href="https://www.cnblogs.com/motadou/p/12667166.html">云风版协程库源代码分析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/84935949">云风coroutine协程库源码分析</a></p>
<p><a href="https://www.jianshu.com/p/a96b31da3ab0">从ucontext到coroutine</a></p>
<h3 id="利用汇编语言来切换运行时上下文。"><a href="#利用汇编语言来切换运行时上下文。" class="headerlink" title="利用汇编语言来切换运行时上下文。"></a>利用汇编语言来切换运行时上下文。</h3><p>参考资料：</p>
<p><a href="https://zhuanlan.zhihu.com/p/51078499">微信开源C++Libco介绍与应用</a></p>
<p><a href="https://www.cnblogs.com/github-Yuandong-Chen/p/6849168.html"> 130行C语言实现个用户态线程库</a></p>
<h3 id="利用C语言语法switch-case来实现切换运行时上下文。"><a href="#利用C语言语法switch-case来实现切换运行时上下文。" class="headerlink" title="利用C语言语法switch-case来实现切换运行时上下文。"></a>利用C语言语法switch-case来实现切换运行时上下文。</h3><p>参考资料Protothreads</p>
<h3 id="利用C语言的setjmp和longjmp"><a href="#利用C语言的setjmp和longjmp" class="headerlink" title="利用C语言的setjmp和longjmp"></a>利用C语言的setjmp和longjmp</h3><h2 id="协程和IO多路复用结合的优点"><a href="#协程和IO多路复用结合的优点" class="headerlink" title="协程和IO多路复用结合的优点"></a>协程和IO多路复用结合的优点</h2><p>【待更】</p>
<h2 id="GoLang的协程"><a href="#GoLang的协程" class="headerlink" title="GoLang的协程"></a>GoLang的协程</h2><p>【待更】</p>
]]></content>
      <tags>
        <tag>GoLang</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/2021/10/15/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>IO (Input/Output，输入/输出)即数据的读取（接收）或写入（发送）操作，通常用户进程中的一个完整IO分为两阶段：用户进程空间&lt;–&gt;内核空间、内核空间&lt;–&gt;设备空间（磁盘、网络等）。IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。</p>
<p>LINUX中进程无法直接操作I/O设备，其必须通过系统调用请求kernel来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。【Read和Write没有用户缓冲区，但是高级语言的标准IO一般都是有缓冲区的】</p>
<h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>阻塞IO顾名思义，这是一种会令自己陷入阻塞状态的IO，所谓阻塞IO就是当进程发起读取数据申请时，在内核缓冲区没有准备好数据之前，进程会一直处于等待数据状态，直到内核把数据准备好了或者发送错误才会返回。【格局放大些，把阻塞IO也理解成阻塞的系统调用，listen、accept都是阻塞的系统调用】</p>
<p><strong>缺点：</strong>阻塞期间，进程将无法执行任何运算或响应其他任何的网络请求。</p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>所谓非阻塞IO就是当应进程发起读取数据申请时，如果内核缓冲区没有数据会返回一个错误标识，应用进程在得到error后，过一段时间再发送读数据请求。在两次发送请求的时间段，进程可以先做别的事情。在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。</p>
<p><strong>缺点：</strong>非阻塞IO性能应该比阻塞IO还差，阻塞IO没数据会进入阻塞状态把CPU让给别的进程，非阻塞IO则会一直霸占的CPU资源，由于轮询的原因还可能会造成多次的用户态-内核态的转换。</p>
<h2 id="IO复用【内核负责轮询】"><a href="#IO复用【内核负责轮询】" class="headerlink" title="IO复用【内核负责轮询】"></a>IO复用【内核负责轮询】</h2><p>IO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd ,select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程。从而达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。【协程+IO复用能有效处理高并发】</p>
<p><strong>优点：</strong>增加了单个进程处理网络连接的能力</p>
<p><strong>缺点：</strong>没有完全解决阻塞问题，fd少的情况下，和阻塞IO性能差别不大，甚至更差，因为IO复用完成一次读数据需要2次系统调用。【异步IOyyds】</p>
<h2 id="信号驱动IO【软中断IO】"><a href="#信号驱动IO【软中断IO】" class="headerlink" title="信号驱动IO【软中断IO】"></a>信号驱动IO【软中断IO】</h2><p>复用IO模型解决了一个线程可以监控多个fd的问题，但是select是采用轮询的方式来监控多个fd的，通过不断的轮询fd的可读状态来知道是否就可读的数据，而无脑的轮询就显得有点暴力，因为大部分情况下的轮询都是无效的，所以有人就想，能不能不要我总是去问你是否数据准备就绪，能不能我发出请求后等你数据准备好了就通知我，所以就衍生了信号驱动IO模型。【中断工作思想】</p>
<p><strong>优点：</strong>避免了IO复用里面大量的轮询。</p>
<h2 id="异步IO【零阻塞IO】"><a href="#异步IO【零阻塞IO】" class="headerlink" title="异步IO【零阻塞IO】"></a>异步IO【零阻塞IO】</h2><p>异步IO下，进程只需要向内核发送一个read 请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用，这种模式为异步IO模型。异步IO是真正非阻塞的，它不会对请求进程产生任何的阻塞。【异步IO由POSIX规范定义，很少有操作系统能实现它们。】</p>
<h2 id="Linux异步IO"><a href="#Linux异步IO" class="headerlink" title="Linux异步IO"></a>Linux异步IO</h2><p>Linux 下的 Posix AIO 是由 glibc 在 user space 用多线程+同步阻塞 IO 模拟的，效率还远不如 epoll。FreeBSD 倒是有原生支持 Posix AIO 的 Kernel Mod。</p>
<p>真正意义上的异步 IO 是比上述 epoll 等多路复用的非阻塞 IO 机制性能更好的通信方式，也是最贴近现代硬件 DMA + 中断工作方式的 IO 编程模型，可以做到内存零拷贝等非阻塞 IO 做不到的性能优化。</p>
<p>Linux 自己其实也有 Kernel 级的 AIO ABI（io_submit），不过跟 Posix AIO API 不兼容，而且还有很多问题，比如：只支持以指定标识（O_DIRECT）打开的文件，不支持 socket 句柄等等。相信未来 Linux AIO 进一步完善以后，glibc 应该会基于这组 syscalls 实现原生 Posix AIO 接口。</p>
<p>作者：白杨<br>链接：<a href="https://www.zhihu.com/question/421584363/answer/1478781492">https://www.zhihu.com/question/421584363/answer/1478781492</a><br>来源：知乎</p>
<h2 id="5种IO的比较图"><a href="#5种IO的比较图" class="headerlink" title="5种IO的比较图"></a>5种IO的比较图</h2><p><img src="https://oscimg.oschina.net/oscnet/f49d44d0f1ecf5b18f7090375aba41ebf2d.png" alt="img"></p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>UXIX环境编程</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC进程通信</title>
    <url>/2021/10/16/IPC%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>-</p>
<span id="more"></span>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>从我们程序员的角度出发，进程是内存中正在运行的一个程序，从操作系统的角度来看，进程就是一个struct结构体，创建和销毁进程也就是创建和销毁一个结构体。【僵尸进程就是一个子进程已经运行完毕调用了exit，但是操作系统没有销毁该结构体的进程，需要父进程给他收尸，这种设计方案能够父进程知道子进程的处于什么状态。】</p>
<h2 id="进程通信的原理"><a href="#进程通信的原理" class="headerlink" title="进程通信的原理"></a>进程通信的原理</h2><p>每个进程的用户地址空间都是独立的，进程相互间无法感应到彼此的存在，但内核空间是每个进，操作系统负责进程的管理，所以进程之间的通信都是由操作系统系统的服务。<strong>进程通信的方法多种多样，但是所有方法的设计思路都是由操作系统提供一块2个进程可以访问的内存区域</strong></p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="信号原理"><a href="#信号原理" class="headerlink" title="信号原理"></a>信号原理</h3><p>信号是在软件层次上对中断机制的一种模拟【软中断】，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。</p>
<p>信号是<strong>进程间通信机制中唯一的异步通信机制</strong>，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。</p>
<h3 id="信号来源"><a href="#信号来源" class="headerlink" title="信号来源"></a>信号来源</h3><p>(1)程序错误，如非法访问内存，还有除0</p>
<p>【当发生整数除 0 之类的错误时, 硬件会触发中断, 这时操作系统会根据上下文查出是哪个进程不给力了, 然后给这个进程发出一个信号，那我能不能修改这个进程对这个信号的处理方法，然后使得这个程序不报错呀。】</p>
<p>(2)外部信号【硬件来源】，如按下了CTRL+C</p>
<p>(3)通过kill或sigqueue向另外一个进程发送信号</p>
<p>信号是一种异步的通信手段，信号只是一个很小的bit，表明是哪一类信号，<strong>并不是大量的数据交换【这条应该算是缺点吧】</strong>，只起到一个通知的作用。这种通信方式很灵活、效率很高。</p>
<p>信号又分可靠和不可靠的信号，不可靠的信号很会发生信号丢失的情况【一个进程如果有了类型k的待处理信号，接下来如果还受到了类型k的信号，则会将这个信号丢弃】</p>
<h3 id="GoLang信号的使用"><a href="#GoLang信号的使用" class="headerlink" title="GoLang信号的使用"></a>GoLang信号的使用</h3><p>GoLang使用channel来监听信号，对应的API在os/signal</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Signal <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">	Signal() <span class="comment">// to distinguish from other Stringers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><h3 id="共享内存的原理"><a href="#共享内存的原理" class="headerlink" title="共享内存的原理"></a>共享内存的原理</h3><p>共享内存的原理是操作系统解除进程间的隔离，修改2个进程的页表，使得它们映射到用一块物理内存，提供了一块共享的<strong>用户态内存</strong>，只需要刚开始时操作系统的介入分配空间，之后就不再需要操作系统的介入，<strong>是最快的IPC通信机制</strong>。</p>
<p>共享内存可以通过mmap映射普通文件（特殊情况下还可以采用匿名映射）机制实现，也可以通过系统V共享内存机制实现【这个机制不会】。</p>
<p>共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据（配合信号量使用）；<strong>这种方式通常适用于多进程间通信。</strong></p>
<h3 id="GoLang共享内存"><a href="#GoLang共享内存" class="headerlink" title="GoLang共享内存"></a>GoLang共享内存</h3><p>golang不提供使用共享内存来通信的API，都是通过cgo来调用C语言来实现的。使用方法看<a href="https://studygolang.com/articles/10203">这里</a></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列我觉得也是共享内存的一种，但是它共享的是一片<strong>内核内存</strong>,消息队列是一块条链表，每个Node是独立的数据单位，每一个数据单位被称为消息体【Pipe中的数据是流数据】。两种模型在操作系统中都常见,消息传递对于交换较少数量的数据很有用，因为无需避免冲突。对于分布式系统，消息传递也比共享内存更易实现。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181102/2-1Q1021345313P.gif" alt="Alt text"></p>
<h3 id="GoLang消息队列"><a href="#GoLang消息队列" class="headerlink" title="GoLang消息队列"></a>GoLang消息队列</h3><p>和共享内存一样，Go不提供封装了消息队列的标准库函数，需要自己用cgo调用。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道同样是操作系统为2个进程提供的一块<strong>半双工内核内存</strong></p>
<p>无名管道：只能用于父子进程或者兄弟进程之间，需要双方通信时，需要建立起两个管道</p>
<p>有名管道：有名管道是为了解决无名管道只能用于近亲进程之间通信的缺陷而设计的。命名管道是建立在实际的磁盘介质或文件系统（而不是只存在于内存中）上有自己名字的文件，任何进程可以在任何时间通过文件名或路径名与该文件建立联系。为了实现命名管道，引入了一种新的文件类型——FIFO文件（遵循先进先出的原则）。实现一个命名管道实际上就是实现一个FIFO文件。命名管道一旦建立，之后它的读、写以及关闭操作都与普通管道完全相同。虽然FIFO文件的inode节点在磁盘上，但是仅是一个节点而已，文件的数据还是存在于内存缓冲页面中，和普通管道相同。<a href="https://blog.csdn.net/yxtxiaotian/article/details/69568774">引自</a></p>
<h3 id="GoLang管道"><a href="#GoLang管道" class="headerlink" title="GoLang管道"></a>GoLang管道</h3><p>API：在os包里</p>
<p>作用：创建命名管道<br>返回值：<br>    r *File  管道输出端<br>    w *File  管道输入端<br>    err error 可能发生的错误<br>注意：命名管道的读/写必须同时进行，否则会阻塞到读/写<br>func Pipe() (r *File, w *File, err error)</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量主要是用来<strong>保护共享资源</strong>，使得资源在一个时刻只有一个进程（线程）所拥有，<strong>信号量一般用来做同步。</strong><br>进程可以根据它判定是否能够访问某些共享资源，同时，进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。</p>
<p>信号量有以下两种类型：</p>
<ul>
<li><strong>二值信号量</strong>： 最简单的信号量形式，信号量的值只能取0或1，类似于互斥锁。 注：二值信号量能够实现互斥锁的功能，但两者的关注内容不同。信号量强调共享资源，只要共享资源可用，其他进程同样可以修改信号量的值；互斥锁更强调进程，占用资源的进程使用完资源后，必须由进程本身来解锁。</li>
<li><strong>计算信号量</strong>：信号量的值可以取任意非负值（当然受内核本身的约束）。</li>
</ul>
<p>Socket</p>
<p>不仅是进程间通信，更是主机间通信，分布式开发的首选。【socket对应的是一个文件，进程可以复用一个socket，进程通过socket通信】</p>
<img src="/images/socket.png" width="80%"  />

<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="http://c.biancheng.net/view/1208.html">消息队列和共享内存</a></p>
<p><a href="https://www.zhihu.com/question/23995948/answer/136236554">各种IPC机制的应用场景</a></p>
<p><a href="https://mp.weixin.qq.com/s/WgZaS5w5IXa3IBGRsPKtbQ">Linux 进程间通信</a></p>
<p><a href="https://www.kancloud.cn/kancloud/understanding-linux-processes/52163">理解Linux进程</a></p>
]]></content>
      <tags>
        <tag>GoLang</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
